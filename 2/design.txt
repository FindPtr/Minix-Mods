x Remove user process checks from balance_queue
o Learn how pick_proc in proc.c works (~1394)
   o Modify pick_proc to function different for user processes
o Learn how sched in proc.c works (~1361)
   o Modify sched to set different queues for user processes
x Modify the proc struct in proc.h
o Figure out what PRIO_MIN and PRIO_MAX are for
o Modify do_nice in system.c
x Modify do_fork to initialize stuff.

# Purpose
The purpose of this project is to design and implement two process schedulers for MINIX. One chooses processes to run according to a "lottery" algorithm, and the other chooses processes to run according to a "round-robin" algorithm.

# Available resources
o pick_proc
o sched
o enqueue
o dequeue
o proc.h struct
o do_nice in system.c
o do_fork

# Design
First, proc.h must be modified. The proc struct must have two additional attributes appended to it: an attribute to keep track of tickets for the lottery algorithm, and an attribute to keep track of quanta expended for the round-robin algorithm. These must be appended to the end of the struct because some ASM code relies on the preceding attributes being in specific off-sets from the beginning of the struct.

Due to the way system processes are spawned, I will also be creating new queue definitions in proc.h. Because the system uses USER_Q for a variety of operations, and I want to separate system processes from user processes in the queues, separate definitions will be used for the custom queues.

## Lottery
### sched():
Do not move user processes.

### pick_proc():
ntickets = Count up the tickets in the queue.
lucky_winner = random()%ntickets;
for(lucky_winner; (lucky_winner - rp->tickets) <= 0; rp = rp->next)
   {}
return rp;


## Round-robin:
### sched():
If the the process's queue has only the sentinel, enqueue to head.
Else, enqueue to tail.
If !time_left,
   ++quanta
   Evaluate for promotion/demotion
else,
   refresh quanta

### dequeue():
If the process is the head, and p->nextready is sentinel,
   dequeue the process, then requeue the sentinel.

### pick_proc():
start = 1
case:
last == 0: break;
last == 1:
   If head is sentinel, requeue & start = 2
last == 2:
   If head is sentinel, requeue & start = 3
last == 3:
   If head is sentinel, requeue.
default:
   Kernel panic.
for (int q = start; i <= 3; i++)
   if (head != sentinel)
      last = q;
      return head[q];
if last == 0
   return NIL_PROC;
else
   last = 0
   pick_proc()

do_fork must be modified to initialize the values we chose to append to the proc struct.

do_nice must be modified to work in accordance with our algorithm (for user processes only) whereby it modifies the number of tickets in the case of lottery (to a number between 0 and 100) and whereby it does nothing (in the case of round-robin).

# Testing
Testing was performed with a program called "longrun.c" which loops endlessly in a non-optimizable way. I also used liberal amounts of kprintf().
